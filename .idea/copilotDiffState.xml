<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;}&#10;&#10;android {&#10;    namespace = &quot;kioskware.vision.demo&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;kioskware.vision.demo&quot;&#10;        minSdk = 29&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;}&#10;&#10;android {&#10;    namespace = &quot;kioskware.vision.demo&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;kioskware.vision.demo&quot;&#10;        minSdk = 29&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.androidx.lifecycle.viewmodel.compose)&#10;&#10;    // Dodanie biblioteki vision&#10;    implementation(project(&quot;:vision&quot;))&#10;&#10;    // Dodatkowe zależności dla kamery&#10;    implementation(libs.androidx.camera.core)&#10;    implementation(libs.androidx.camera.camera2)&#10;    implementation(libs.androidx.camera.lifecycle)&#10;    implementation(libs.androidx.camera.view)&#10;    implementation(&quot;androidx.compose.material:material-icons-extended:1.5.4&quot;)&#10;&#10;&#10;&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/kioskware/vision/demo/MainViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/kioskware/vision/demo/MainViewModel.kt" />
              <option name="originalContent" value="package kioskware.vision.demo&#10;&#10;import android.content.Context&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import kioskware.vision.camera.BackendCamera&#10;import kioskware.vision.camera.BackendCameras&#10;import kioskware.vision.camera.CameraParams&#10;import kioskware.vision.impl.defaultBackendCameras&#10;&#10;internal class MainViewModel : ViewModel() {&#10;    private val _uiState = MutableStateFlow(MainUiState())&#10;    val uiState: StateFlow&lt;MainUiState&gt; = _uiState.asStateFlow()&#10;&#10;    private var backendCameras: BackendCameras? = null&#10;    private var currentBackendCamera: BackendCamera? = null&#10;    private var lifecycleOwner: androidx.lifecycle.LifecycleOwner? = null&#10;    private var diagnostics: CameraDetectionDiagnostics? = null&#10;&#10;    fun initializeCameras(context: Context) {&#10;        // Zapisz LifecycleOwner jeśli context jest ComponentActivity&#10;        if (context is androidx.lifecycle.LifecycleOwner) {&#10;            lifecycleOwner = context&#10;        }&#10;&#10;        // Inicjalizuj diagnostykę&#10;        diagnostics = CameraDetectionDiagnostics(context)&#10;&#10;        viewModelScope.launch {&#10;            try {&#10;                val cameras = defaultBackendCameras(context)&#10;                backendCameras = cameras&#10;&#10;                // Obserwuj dostępne kamery&#10;                cameras.availableCameras.collect { availableCameras -&gt;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        availableCameras = availableCameras,&#10;                        isLoading = false&#10;                    )&#10;&#10;                    // Automatycznie wybierz pierwszą dostępną kamerę&#10;                    if (_uiState.value.selectedCamera == null &amp;&amp; availableCameras.isNotEmpty()) {&#10;                        selectCamera(availableCameras.first())&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    error = &quot;Błąd inicjalizacji kamer: ${e.message}&quot;,&#10;                    isLoading = false&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun selectCamera(cameraParams: CameraParams) {&#10;        viewModelScope.launch {&#10;            try {&#10;                // Zatrzymaj obecną kamerę jeśli jest aktywna&#10;                currentBackendCamera?.let { camera -&gt;&#10;                    camera.stopCamera()&#10;                }&#10;&#10;                val camera = backendCameras?.getCamera(cameraParams)&#10;                currentBackendCamera = camera&#10;&#10;                _uiState.value = _uiState.value.copy(&#10;                    selectedCamera = cameraParams,&#10;                    currentBackendCamera = camera,&#10;                    error = null&#10;                )&#10;&#10;                // Automatycznie uruchom nową kamerę&#10;                startCamera()&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    error = &quot;Błąd wyboru kamery: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun startCamera() {&#10;        viewModelScope.launch {&#10;            try {&#10;                val owner = lifecycleOwner&#10;                val camera = currentBackendCamera&#10;&#10;                if (owner != null &amp;&amp; camera != null) {&#10;                    camera.startCamera(&#10;                        lifecycleOwner = owner,&#10;                        resolution = android.util.Size(1280, 720),&#10;                        backpressureStrategy = kioskware.vision.BackpressureStrategy.KeepOnlyLatest,&#10;                        targetRotation = kioskware.vision.Rotation.Degrees0,&#10;                        outputImageFormat = kioskware.vision.OutputImageFormat.YUV_420_888,&#10;                        imageProcessors = emptyList()&#10;                    )&#10;                } else {&#10;                    _uiState.value = _uiState.value.copy(&#10;                        error = &quot;Nie można uruchomić kamery - brak LifecycleOwner lub kamery&quot;&#10;                    )&#10;                }&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    error = &quot;Błąd uruchamiania kamery: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearError() {&#10;        _uiState.value = _uiState.value.copy(error = null)&#10;    }&#10;&#10;    fun setCameraPermission(hasPermission: Boolean) {&#10;        _uiState.value = _uiState.value.copy(hasCameraPermission = hasPermission)&#10;    }&#10;&#10;    fun setDropdownExpanded(expanded: Boolean) {&#10;        _uiState.value = _uiState.value.copy(isDropdownExpanded = expanded)&#10;    }&#10;&#10;    fun runCameraDiagnostics() {&#10;        viewModelScope.launch {&#10;            try {&#10;                _uiState.value = _uiState.value.copy(&#10;                    isDiagnosticsRunning = true,&#10;                    diagnosticsResult = null&#10;                )&#10;&#10;                val report = diagnostics?.runFullDiagnostics() ?: &quot;Diagnostyka niedostępna&quot;&#10;&#10;                _uiState.value = _uiState.value.copy(&#10;                    isDiagnosticsRunning = false,&#10;                    diagnosticsResult = report&#10;                )&#10;            } catch (e: Exception) {&#10;                _uiState.value = _uiState.value.copy(&#10;                    isDiagnosticsRunning = false,&#10;                    error = &quot;Błąd diagnostyki: ${e.message}&quot;&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearDiagnosticsResult() {&#10;        _uiState.value = _uiState.value.copy(diagnosticsResult = null)&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        // Zatrzymaj kamerę gdy ViewModel jest czyszczony&#10;        currentBackendCamera?.let { camera -&gt;&#10;            viewModelScope.launch {&#10;                try {&#10;                    camera.stopCamera()&#10;                } catch (e: Exception) {&#10;                    // Log błędu przy zatrzymywaniu kamery&#10;                    println(&quot;Błąd zatrzymywania kamery: ${e.message}&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;data class MainUiState(&#10;    val hasCameraPermission: Boolean = false,&#10;    val availableCameras: List&lt;CameraParams&gt; = emptyList(),&#10;    val selectedCamera: CameraParams? = null,&#10;    val currentBackendCamera: BackendCamera? = null,&#10;    val isDropdownExpanded: Boolean = false,&#10;    val isLoading: Boolean = true,&#10;    val error: String? = null,&#10;    val isDiagnosticsRunning: Boolean = false,&#10;    val diagnosticsResult: String? = null&#10;)&#10;" />
              <option name="updatedContent" value="package kioskware.vision.demo&#13;&#10;&#13;&#10;import android.content.Context&#13;&#10;import androidx.lifecycle.ViewModel&#13;&#10;import androidx.lifecycle.viewModelScope&#13;&#10;import kotlinx.coroutines.flow.MutableStateFlow&#13;&#10;import kotlinx.coroutines.flow.StateFlow&#13;&#10;import kotlinx.coroutines.flow.asStateFlow&#13;&#10;import kotlinx.coroutines.launch&#13;&#10;import kioskware.vision.camera.BackendCamera&#13;&#10;import kioskware.vision.camera.BackendCameras&#13;&#10;import kioskware.vision.camera.CameraParams&#13;&#10;import kioskware.vision.impl.defaultBackendCameras&#13;&#10;&#13;&#10;class MainViewModel : ViewModel() {&#13;&#10;    private val _uiState = MutableStateFlow(MainUiState())&#13;&#10;    val uiState: StateFlow&lt;MainUiState&gt; = _uiState.asStateFlow()&#13;&#10;&#13;&#10;    private var backendCameras: BackendCameras? = null&#13;&#10;    private var currentBackendCamera: BackendCamera? = null&#13;&#10;    private var lifecycleOwner: androidx.lifecycle.LifecycleOwner? = null&#13;&#10;    private var diagnostics: CameraDetectionDiagnostics? = null&#13;&#10;&#13;&#10;    fun initializeCameras(context: Context) {&#13;&#10;        // Zapisz LifecycleOwner jeśli context jest ComponentActivity&#13;&#10;        if (context is androidx.lifecycle.LifecycleOwner) {&#13;&#10;            lifecycleOwner = context&#13;&#10;        }&#13;&#10;&#13;&#10;        // Inicjalizuj diagnostykę&#13;&#10;        diagnostics = CameraDetectionDiagnostics(context)&#13;&#10;&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                val cameras = defaultBackendCameras(context)&#13;&#10;                backendCameras = cameras&#13;&#10;&#13;&#10;                // Obserwuj dostępne kamery&#13;&#10;                cameras.availableCameras.collect { availableCameras -&gt;&#13;&#10;                    _uiState.value = _uiState.value.copy(&#13;&#10;                        availableCameras = availableCameras,&#13;&#10;                        isLoading = false&#13;&#10;                    )&#13;&#10;&#13;&#10;                    // Automatycznie wybierz pierwszą dostępną kamerę&#13;&#10;                    if (_uiState.value.selectedCamera == null &amp;&amp; availableCameras.isNotEmpty()) {&#13;&#10;                        selectCamera(availableCameras.first())&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    error = &quot;Błąd inicjalizacji kamer: ${e.message}&quot;,&#13;&#10;                    isLoading = false&#13;&#10;                )&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun selectCamera(cameraParams: CameraParams) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                // Zatrzymaj obecną kamerę jeśli jest aktywna&#13;&#10;                currentBackendCamera?.let { camera -&gt;&#13;&#10;                    camera.stopCamera()&#13;&#10;                }&#13;&#10;&#13;&#10;                val camera = backendCameras?.getCamera(cameraParams)&#13;&#10;                currentBackendCamera = camera&#13;&#10;&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    selectedCamera = cameraParams,&#13;&#10;                    currentBackendCamera = camera,&#13;&#10;                    error = null&#13;&#10;                )&#13;&#10;&#13;&#10;                // Automatycznie uruchom nową kamerę&#13;&#10;                startCamera()&#13;&#10;            } catch (e: Exception) {&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    error = &quot;Błąd wyboru kamery: ${e.message}&quot;&#13;&#10;                )&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun startCamera() {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                val owner = lifecycleOwner&#13;&#10;                val camera = currentBackendCamera&#13;&#10;&#13;&#10;                if (owner != null &amp;&amp; camera != null) {&#13;&#10;                    camera.startCamera(&#13;&#10;                        lifecycleOwner = owner,&#13;&#10;                        resolution = android.util.Size(1280, 720),&#13;&#10;                        backpressureStrategy = kioskware.vision.BackpressureStrategy.KeepOnlyLatest,&#13;&#10;                        targetRotation = kioskware.vision.Rotation.Degrees0,&#13;&#10;                        outputImageFormat = kioskware.vision.OutputImageFormat.YUV_420_888,&#13;&#10;                        imageProcessors = emptyList()&#13;&#10;                    )&#13;&#10;                } else {&#13;&#10;                    _uiState.value = _uiState.value.copy(&#13;&#10;                        error = &quot;Nie można uruchomić kamery - brak LifecycleOwner lub kamery&quot;&#13;&#10;                    )&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    error = &quot;Błąd uruchamiania kamery: ${e.message}&quot;&#13;&#10;                )&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun clearError() {&#13;&#10;        _uiState.value = _uiState.value.copy(error = null)&#13;&#10;    }&#13;&#10;&#13;&#10;    fun setCameraPermission(hasPermission: Boolean) {&#13;&#10;        _uiState.value = _uiState.value.copy(hasCameraPermission = hasPermission)&#13;&#10;    }&#13;&#10;&#13;&#10;    fun setDropdownExpanded(expanded: Boolean) {&#13;&#10;        _uiState.value = _uiState.value.copy(isDropdownExpanded = expanded)&#13;&#10;    }&#13;&#10;&#13;&#10;    fun runCameraDiagnostics() {&#13;&#10;        viewModelScope.launch {&#13;&#10;            try {&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    isDiagnosticsRunning = true,&#13;&#10;                    diagnosticsResult = null&#13;&#10;                )&#13;&#10;&#13;&#10;                val report = diagnostics?.runFullDiagnostics() ?: &quot;Diagnostyka niedostępna&quot;&#13;&#10;&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    isDiagnosticsRunning = false,&#13;&#10;                    diagnosticsResult = report&#13;&#10;                )&#13;&#10;            } catch (e: Exception) {&#13;&#10;                _uiState.value = _uiState.value.copy(&#13;&#10;                    isDiagnosticsRunning = false,&#13;&#10;                    error = &quot;Błąd diagnostyki: ${e.message}&quot;&#13;&#10;                )&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun clearDiagnosticsResult() {&#13;&#10;        _uiState.value = _uiState.value.copy(diagnosticsResult = null)&#13;&#10;    }&#13;&#10;&#13;&#10;    override fun onCleared() {&#13;&#10;        super.onCleared()&#13;&#10;        // Zatrzymaj kamerę gdy ViewModel jest czyszczony&#13;&#10;        currentBackendCamera?.let { camera -&gt;&#13;&#10;            viewModelScope.launch {&#13;&#10;                try {&#13;&#10;                    camera.stopCamera()&#13;&#10;                } catch (e: Exception) {&#13;&#10;                    // Log błędu przy zatrzymywaniu kamery&#13;&#10;                    println(&quot;Błąd zatrzymywania kamery: ${e.message}&quot;)&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;data class MainUiState(&#13;&#10;    val hasCameraPermission: Boolean = false,&#13;&#10;    val availableCameras: List&lt;CameraParams&gt; = emptyList(),&#13;&#10;    val selectedCamera: CameraParams? = null,&#13;&#10;    val currentBackendCamera: BackendCamera? = null,&#13;&#10;    val isDropdownExpanded: Boolean = false,&#13;&#10;    val isLoading: Boolean = true,&#13;&#10;    val error: String? = null,&#13;&#10;    val isDiagnosticsRunning: Boolean = false,&#13;&#10;    val diagnosticsResult: String? = null&#13;&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/vision/src/main/java/kioskware/vision/impl/CameraDetectionDiagnostics.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/vision/src/main/java/kioskware/vision/impl/CameraDetectionDiagnostics.kt" />
              <option name="updatedContent" value="package kioskware.vision.impl&#10;&#10;import android.content.Context&#10;import android.hardware.camera2.CameraCharacteristics&#10;import android.hardware.camera2.CameraManager&#10;import android.util.Log&#10;&#10;/**&#10; * Enhanced diagnostic tool for camera detection issues&#10; */&#10;internal class CameraDetectionDiagnostics(private val context: Context) {&#10;    &#10;    private val TAG = &quot;CameraDetectionDiag&quot;&#10;    &#10;    suspend fun runFullDiagnostics(): String {&#10;        val report = StringBuilder()&#10;        val cameraManager = context.getSystemService(Context.CAMERA_SERVICE) as CameraManager&#10;        &#10;        try {&#10;            val cameraIds = cameraManager.cameraIdList&#10;            report.appendLine(&quot;=== DIAGNOZA KAMER ===&quot;)&#10;            report.appendLine(&quot;Znalezione ID kamer: ${cameraIds.size}&quot;)&#10;            report.appendLine(&quot;Lista ID: ${cameraIds.joinToString(&quot;, &quot;)}&quot;)&#10;            report.appendLine()&#10;            &#10;            val frontCameras = mutableListOf&lt;String&gt;()&#10;            val backCameras = mutableListOf&lt;String&gt;()&#10;            val externalCameras = mutableListOf&lt;String&gt;()&#10;            val unknownCameras = mutableListOf&lt;String&gt;()&#10;            val logicalCameras = mutableListOf&lt;String&gt;()&#10;            val physicalCameras = mutableListOf&lt;String&gt;()&#10;            &#10;            for (cameraId in cameraIds) {&#10;                try {&#10;                    val characteristics = cameraManager.getCameraCharacteristics(cameraId)&#10;                    &#10;                    // Sprawdź kierunek kamery&#10;                    val facing = characteristics.get(CameraCharacteristics.LENS_FACING)&#10;                    when (facing) {&#10;                        CameraCharacteristics.LENS_FACING_FRONT -&gt; frontCameras.add(cameraId)&#10;                        CameraCharacteristics.LENS_FACING_BACK -&gt; backCameras.add(cameraId)&#10;                        CameraCharacteristics.LENS_FACING_EXTERNAL -&gt; externalCameras.add(cameraId)&#10;                        else -&gt; unknownCameras.add(cameraId)&#10;                    }&#10;                    &#10;                    // Sprawdź czy to kamera logiczna&#10;                    val physicalCameraIds = try {&#10;                        if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.P) {&#10;                            characteristics.physicalCameraIds&#10;                        } else {&#10;                            emptySet()&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        emptySet&lt;String&gt;()&#10;                    }&#10;                    &#10;                    if (physicalCameraIds.isNotEmpty()) {&#10;                        logicalCameras.add(cameraId)&#10;                    } else {&#10;                        physicalCameras.add(cameraId)&#10;                    }&#10;                    &#10;                    // Szczegółowe informacje o kamerze&#10;                    val hardwareLevel = characteristics.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL)&#10;                    val capabilities = characteristics.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES)&#10;                    val isBackwardCompatible = capabilities?.contains(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE) ?: false&#10;                    &#10;                    report.appendLine(&quot;Kamera $cameraId:&quot;)&#10;                    report.appendLine(&quot;  - Kierunek: ${getFacingString(facing)}&quot;)&#10;                    report.appendLine(&quot;  - Poziom sprzętowy: ${getHardwareLevelString(hardwareLevel)}&quot;)&#10;                    report.appendLine(&quot;  - Kompatybilność wsteczna: $isBackwardCompatible&quot;)&#10;                    report.appendLine(&quot;  - Typ: ${if (physicalCameraIds.isNotEmpty()) &quot;Logiczna&quot; else &quot;Fizyczna&quot;}&quot;)&#10;                    &#10;                    if (physicalCameraIds.isNotEmpty()) {&#10;                        report.appendLine(&quot;  - Fizyczne kamery: ${physicalCameraIds.joinToString(&quot;, &quot;)}&quot;)&#10;                    }&#10;                    &#10;                    // Sprawdź dostępne rozdzielczości&#10;                    val configMap = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)&#10;                    val jpegSizes = configMap?.getOutputSizes(android.graphics.ImageFormat.JPEG)&#10;                    report.appendLine(&quot;  - Rozdzielczości JPEG: ${jpegSizes?.size ?: 0}&quot;)&#10;                    &#10;                    report.appendLine()&#10;                    &#10;                } catch (e: Exception) {&#10;                    report.appendLine(&quot;BŁĄD przy analizie kamery $cameraId: ${e.message}&quot;)&#10;                    Log.e(TAG, &quot;Error analyzing camera $cameraId&quot;, e)&#10;                }&#10;            }&#10;            &#10;            report.appendLine(&quot;=== PODSUMOWANIE ===&quot;)&#10;            report.appendLine(&quot;Kamery przednie: ${frontCameras.size} (${frontCameras.joinToString(&quot;, &quot;)})&quot;)&#10;            report.appendLine(&quot;Kamery tylne: ${backCameras.size} (${backCameras.joinToString(&quot;, &quot;)})&quot;)&#10;            report.appendLine(&quot;Kamery zewnętrzne: ${externalCameras.size} (${externalCameras.joinToString(&quot;, &quot;)})&quot;)&#10;            report.appendLine(&quot;Kamery nieznane: ${unknownCameras.size} (${unknownCameras.joinToString(&quot;, &quot;)})&quot;)&#10;            report.appendLine()&#10;            report.appendLine(&quot;Kamery logiczne: ${logicalCameras.size} (${logicalCameras.joinToString(&quot;, &quot;)})&quot;)&#10;            report.appendLine(&quot;Kamery fizyczne: ${physicalCameras.size} (${physicalCameras.joinToString(&quot;, &quot;)})&quot;)&#10;            &#10;            // Analiza potencjalnych problemów&#10;            report.appendLine()&#10;            report.appendLine(&quot;=== ANALIZA PROBLEMÓW ===&quot;)&#10;            &#10;            if (frontCameras.size &gt; 1) {&#10;                report.appendLine(&quot;⚠️ PROBLEM: Wykryto ${frontCameras.size} kamer przednich - prawdopodobnie kamery logiczne zawierają duplikaty&quot;)&#10;            }&#10;            &#10;            if (logicalCameras.isNotEmpty()) {&#10;                report.appendLine(&quot;ℹ️ INFO: Wykryto kamery logiczne - mogą one powodować wielokrotne wykrywanie tej samej kamery fizycznej&quot;)&#10;            }&#10;            &#10;            if (backCameras.isEmpty()) {&#10;                report.appendLine(&quot;⚠️ PROBLEM: Nie wykryto żadnych kamer tylnych&quot;)&#10;            }&#10;            &#10;        } catch (e: Exception) {&#10;            report.appendLine(&quot;KRYTYCZNY BŁĄD: ${e.message}&quot;)&#10;            Log.e(TAG, &quot;Critical error in diagnostics&quot;, e)&#10;        }&#10;        &#10;        val result = report.toString()&#10;        Log.d(TAG, result)&#10;        return result&#10;    }&#10;    &#10;    private fun getFacingString(facing: Int?): String {&#10;        return when (facing) {&#10;            CameraCharacteristics.LENS_FACING_FRONT -&gt; &quot;Przednia&quot;&#10;            CameraCharacteristics.LENS_FACING_BACK -&gt; &quot;Tylna&quot;&#10;            CameraCharacteristics.LENS_FACING_EXTERNAL -&gt; &quot;Zewnętrzna&quot;&#10;            else -&gt; &quot;Nieznana ($facing)&quot;&#10;        }&#10;    }&#10;    &#10;    private fun getHardwareLevelString(level: Int?): String {&#10;        return when (level) {&#10;            CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY -&gt; &quot;Legacy&quot;&#10;            CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED -&gt; &quot;Limited&quot;&#10;            CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_FULL -&gt; &quot;Full&quot;&#10;            CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_3 -&gt; &quot;Level 3&quot;&#10;            else -&gt; &quot;Nieznany ($level)&quot;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/vision/src/main/java/kioskware/vision/impl/CameraDiagnostics.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/vision/src/main/java/kioskware/vision/impl/CameraDiagnostics.kt" />
              <option name="updatedContent" value="package kioskware.vision.impl&#10;&#10;import android.content.Context&#10;import android.hardware.camera2.CameraCharacteristics&#10;import android.hardware.camera2.CameraManager&#10;import android.util.Log&#10;&#10;/**&#10; * Diagnostic class to help identify camera detection issues&#10; */&#10;internal class CameraDiagnostics(private val context: Context) {&#10;    &#10;    suspend fun diagnoseCameras() {&#10;        val cameraManager = context.getSystemService(Context.CAMERA_SERVICE) as CameraManager&#10;        &#10;        try {&#10;            val cameraIds = cameraManager.cameraIdList&#10;            Log.d(&quot;CameraDiagnostics&quot;, &quot;Total cameras found: ${cameraIds.size}&quot;)&#10;            &#10;            for (cameraId in cameraIds) {&#10;                try {&#10;                    val characteristics = cameraManager.getCameraCharacteristics(cameraId)&#10;                    &#10;                    // Get basic info&#10;                    val facing = characteristics.get(CameraCharacteristics.LENS_FACING)&#10;                    val facingString = when (facing) {&#10;                        CameraCharacteristics.LENS_FACING_FRONT -&gt; &quot;FRONT&quot;&#10;                        CameraCharacteristics.LENS_FACING_BACK -&gt; &quot;BACK&quot;&#10;                        CameraCharacteristics.LENS_FACING_EXTERNAL -&gt; &quot;EXTERNAL&quot;&#10;                        else -&gt; &quot;UNKNOWN($facing)&quot;&#10;                    }&#10;                    &#10;                    // Get hardware level&#10;                    val hardwareLevel = characteristics.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL)&#10;                    val levelString = when (hardwareLevel) {&#10;                        CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY -&gt; &quot;LEGACY&quot;&#10;                        CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED -&gt; &quot;LIMITED&quot;&#10;                        CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_FULL -&gt; &quot;FULL&quot;&#10;                        CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL_3 -&gt; &quot;LEVEL_3&quot;&#10;                        else -&gt; &quot;UNKNOWN($hardwareLevel)&quot;&#10;                    }&#10;                    &#10;                    // Check capabilities&#10;                    val capabilities = characteristics.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES)&#10;                    val capabilitiesString = capabilities?.joinToString(&quot;, &quot;) ?: &quot;NONE&quot;&#10;                    &#10;                    // Check if it's a logical multi-camera&#10;                    val physicalCameraIds = try {&#10;                        characteristics.physicalCameraIds&#10;                    } catch (e: Exception) {&#10;                        emptySet&lt;String&gt;()&#10;                    }&#10;                    val isLogicalCamera = physicalCameraIds.isNotEmpty()&#10;                    &#10;                    Log.d(&quot;CameraDiagnostics&quot;, &quot;&quot;&quot;&#10;                        Camera ID: $cameraId&#10;                        Facing: $facingString&#10;                        Hardware Level: $levelString&#10;                        Capabilities: $capabilitiesString&#10;                        Is Logical Camera: $isLogicalCamera&#10;                        Physical Camera IDs: ${physicalCameraIds.joinToString(&quot;, &quot;)}&#10;                        ---&#10;                    &quot;&quot;&quot;.trimIndent())&#10;                    &#10;                } catch (e: Exception) {&#10;                    Log.e(&quot;CameraDiagnostics&quot;, &quot;Error analyzing camera $cameraId: ${e.message}&quot;, e)&#10;                }&#10;            }&#10;            &#10;        } catch (e: Exception) {&#10;            Log.e(&quot;CameraDiagnostics&quot;, &quot;Error getting camera list: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>